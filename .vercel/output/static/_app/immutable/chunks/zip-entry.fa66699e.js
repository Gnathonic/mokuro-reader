import{U as f,_ as d,$ as Y}from"./index.9c9c4205.js";let u=[];const N=[];let O=0;async function _e(t,e){const{options:i,config:s}=e,{transferStreams:a,useWebWorkers:c,useCompressionStream:n,codecType:E,compressed:o,signed:R,encrypted:l}=i,{workerScripts:r,maxWorkers:A}=s;e.transferStreams=a||a===f;const P=!o&&!R&&!l&&!e.transferStreams;return e.useWebWorkers=!P&&(c||c===f&&s.useWebWorkers),e.scripts=e.useWebWorkers&&r?r[E]:[],i.useCompressionStream=n||n===f&&s.useCompressionStream,(await I()).run();async function I(){const _=u.find(T=>!T.busy);if(_)return M(_),new d(_,t,e,m);if(u.length<A){const T={indexWorker:O};return O++,u.push(T),new d(T,t,e,m)}else return new Promise(T=>N.push({resolve:T,stream:t,workerOptions:e}))}function m(_){if(N.length){const[{resolve:T,stream:w,workerOptions:C}]=N.splice(0,1);T(new d(_,w,C,m))}else _.worker?(M(_),F(_,e)):u=u.filter(T=>T!=_)}}function F(t,e){const{config:i}=e,{terminateWorkerTimeout:s}=i;Number.isFinite(s)&&s>=0&&(t.terminated?t.terminated=!1:t.terminateTimeout=setTimeout(async()=>{u=u.filter(a=>a!=t);try{await t.terminate()}catch{}},s))}function M(t){const{terminateTimeout:e}=t;e&&(clearTimeout(e),t.terminateTimeout=null)}const x="Writer iterator completed too soon",D="text/plain",W="Content-Type",L=64*1024,p="writable";class S{constructor(){this.size=0}init(){this.initialized=!0}}class z extends S{get readable(){const e=this,{chunkSize:i=L}=e,s=new ReadableStream({start(){this.chunkOffset=0},async pull(a){const{offset:c=0,size:n,diskNumberStart:E}=s,{chunkOffset:o}=this;a.enqueue(await b(e,c+o,Math.min(i,n-o),E)),o+i>n?a.close():this.chunkOffset+=i}});return s}}class U extends z{constructor(e){super(),Object.assign(this,{blob:e,size:e.size})}async readUint8Array(e,i){const s=this,a=e+i;let n=await(e||a<s.size?s.blob.slice(e,a):s.blob).arrayBuffer();return n.byteLength>i&&(n=n.slice(e,a)),new Uint8Array(n)}}class Re extends S{constructor(e){super();const i=this,s=new TransformStream,a=[];e&&a.push([W,e]),Object.defineProperty(i,p,{get(){return s.writable}}),i.blob=new Response(s.readable,{headers:a}).blob()}getData(){return this.blob}}class ue extends U{constructor(e){super(new Blob([e],{type:D}))}}class g extends z{constructor(e){super(),this.readers=e}async init(){const e=this,{readers:i}=e;e.lastDiskNumber=0,e.lastDiskOffset=0,await Promise.all(i.map(async(s,a)=>{await s.init(),a!=i.length-1&&(e.lastDiskOffset+=s.size),e.size+=s.size})),super.init()}async readUint8Array(e,i,s=0){const a=this,{readers:c}=this;let n,E=s;E==-1&&(E=c.length-1);let o=e;for(;o>=c[E].size;)o-=c[E].size,E++;const R=c[E],l=R.size;if(o+i<=l)n=await b(R,o,i);else{const r=l-o;n=new Uint8Array(i),n.set(await b(R,o,r)),n.set(await a.readUint8Array(e+r,i-r,s),r)}return a.lastDiskNumber=Math.max(E,a.lastDiskNumber),n}}class y extends S{constructor(e,i=4294967295){super();const s=this;Object.assign(s,{diskNumber:0,diskOffset:0,size:0,maxSize:i,availableSize:i});let a,c,n;const E=new WritableStream({async write(l){const{availableSize:r}=s;if(n)l.length>=r?(await o(l.slice(0,r)),await R(),s.diskOffset+=a.size,s.diskNumber++,n=null,await this.write(l.slice(r))):await o(l);else{const{value:A,done:P}=await e.next();if(P&&!A)throw new Error(x);a=A,a.size=0,a.maxSize&&(s.maxSize=a.maxSize),s.availableSize=s.maxSize,await k(a),c=A.writable,n=c.getWriter(),await this.write(l)}},async close(){await n.ready,await R()}});Object.defineProperty(s,p,{get(){return E}});async function o(l){const r=l.length;r&&(await n.ready,await n.write(l),a.size+=r,s.size+=r,s.availableSize-=r)}async function R(){c.size=a.size,await n.close()}}}async function k(t,e){if(t.init&&!t.initialized)await t.init(e);else return Promise.resolve()}function Ae(t){return Array.isArray(t)&&(t=new g(t)),t instanceof ReadableStream&&(t={readable:t}),t}function fe(t){t.writable===f&&typeof t.next==Y&&(t=new y(t)),t instanceof WritableStream&&(t={writable:t});const{writable:e}=t;return e.size===f&&(e.size=0),t instanceof y||Object.assign(t,{diskNumber:0,diskOffset:0,availableSize:1/0,maxSize:1/0}),t}function b(t,e,i,s){return t.readUint8Array(e,i,s)}const B="filename",v="rawFilename",j="comment",Z="rawComment",X="uncompressedSize",q="compressedSize",H="offset",h="diskNumberStart",V="lastModDate",K="rawLastModDate",G="lastAccessDate",Pe="rawLastAccessDate",$="creationDate",me="rawCreationDate",J="internalFileAttribute",Q="internalFileAttributes",ee="externalFileAttribute",te="externalFileAttributes",se="msDosCompatible",ie="zip64",ae="encrypted",ne="version",re="versionMadeBy",oe="zipCrypto",ce="directory",Ee="executable",le=[B,v,q,X,V,K,j,Z,G,$,H,h,h,J,Q,ee,te,se,ie,ae,ne,re,oe,ce,Ee,"bitFlag","signature","filenameUTF8","commentUTF8","compressionMethod","extraField","rawExtraField","extraFieldZip64","extraFieldUnicodePath","extraFieldUnicodeComment","extraFieldAES","extraFieldNTFS","extraFieldExtendedTimestamp"];class de{constructor(e){le.forEach(i=>this[i]=e[i])}}export{Z as A,Re as B,j as C,K as D,de as E,Pe as F,me as G,se as P,ue as T,Ae as a,k as b,re as c,Ee as d,te as e,ee as f,ce as g,ne as h,fe as i,V as j,G as k,$ as l,Q as m,J as n,oe as o,ie as p,ae as q,_e as r,U as s,b as t,X as u,q as v,H as w,h as x,v as y,B as z};
