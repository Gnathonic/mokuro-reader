var k=Object.defineProperty;var u=(n,e,r)=>e in n?k(n,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):n[e]=r;var a=(n,e,r)=>(u(n,typeof e!="symbol"?e+"":e,r),r);function m(){return new Worker(""+new URL("../workers/download-worker-73f207d7.js",import.meta.url).href)}class l{constructor(e,r=4,s=500){a(this,"workers",[]);a(this,"taskQueue",[]);a(this,"activeTasks",new Map);a(this,"workerTaskMap",new Map);a(this,"maxConcurrent");a(this,"currentMemoryUsage",0);a(this,"maxMemoryUsage",500*1024*1024);this.maxConcurrent=Math.max(1,Math.min(r,navigator.hardwareConcurrency||4)),this.maxMemoryUsage=s*1024*1024;for(let o=0;o<this.maxConcurrent;o++)this.addWorker()}addWorker(){const e=new m;e.onmessage=r=>{var i;const s=this.workerTaskMap.get(e);if(!s){console.warn("Worker pool: Received message but no taskId found",r.data);return}const o=this.activeTasks.get(s);if(!o){console.warn("Worker pool: Received message but no task found for taskId",s,r.data);return}const t=r.data;console.log(`Worker pool: Received message of type ${t.type} for task ${s}`,t),t.type==="progress"&&o.onProgress?o.onProgress(t):t.type==="complete"&&o.onComplete?(console.log(`Worker pool: Calling onComplete for task ${s}`,{hasData:!!t.data,dataType:typeof t.data,dataSize:(i=t.data)==null?void 0:i.byteLength}),o.onComplete(t,()=>{this.completeTask(e)})):t.type==="error"&&o.onError&&(console.error(`Worker pool: Error for task ${s}:`,t.error),o.onError(t),this.completeTask(e))},e.onerror=r=>{console.error("Worker pool: Worker error event:",r);const s=this.workerTaskMap.get(e);if(!s){console.warn("Worker pool: Error event but no taskId found");return}const o=this.activeTasks.get(s);o&&o.onError?(console.error(`Worker pool: Calling onError for task ${s}`,r.message),o.onError({type:"error",fileId:s,error:r.message})):console.warn(`Worker pool: No onError handler for task ${s}`),this.completeTask(e)},this.workers.push(e),this.workerTaskMap.set(e,null)}completeTask(e){const r=this.workerTaskMap.get(e);if(r){const s=this.activeTasks.get(r);s&&s.memoryRequirement&&(this.currentMemoryUsage=Math.max(0,this.currentMemoryUsage-s.memoryRequirement),console.log(`Task ${r} completed. Memory freed: ${s.memoryRequirement/(1024*1024)} MB. Current usage: ${this.currentMemoryUsage/(1024*1024)} MB`)),this.activeTasks.delete(r),this.workerTaskMap.set(e,null)}this.processQueue()}processQueue(){for(;this.taskQueue.length>0;){const e=this.workers.find(o=>this.workerTaskMap.get(o)===null);if(!e)break;const r=this.taskQueue[0],s=r.memoryRequirement||0;if(this.currentMemoryUsage>this.maxMemoryUsage&&this.activeTasks.size>0){console.log(`Memory usage already exceeds limit. Waiting for tasks to complete before starting new ones. Current: ${this.currentMemoryUsage/(1024*1024)} MB, Max: ${this.maxMemoryUsage/(1024*1024)} MB`);break}this.taskQueue.shift(),this.currentMemoryUsage+=s,console.log(`Starting task ${r.id}. Memory required: ${s/(1024*1024)} MB. Current usage: ${this.currentMemoryUsage/(1024*1024)} MB`),this.assignTaskToWorker(e,r)}}assignTaskToWorker(e,r){this.activeTasks.set(r.id,r),this.workerTaskMap.set(e,r.id),e.postMessage(r.data)}addTask(e){e.memoryRequirement===void 0&&(e.memoryRequirement=50*1024*1024),this.taskQueue.push(e),this.processQueue()}terminate(){for(const e of this.workers)e.terminate();this.workers=[],this.taskQueue=[],this.activeTasks.clear(),this.workerTaskMap.clear()}get activeTaskCount(){return this.activeTasks.size}get queuedTaskCount(){return this.taskQueue.length}get totalPendingTasks(){return this.activeTaskCount+this.queuedTaskCount}get memoryUsage(){return{current:this.currentMemoryUsage,max:this.maxMemoryUsage,percentUsed:this.currentMemoryUsage/this.maxMemoryUsage*100}}}export{l as WorkerPool};
